%header
{
    #include "ast.hpp"
    ASTNode *parse(const char *filename);
}

%include
{
    #include <iostream>
    #include <string>
    #include "error.hpp"
    #include "ast.hpp"
    #include "symbolTable.hpp"

    extern int yylineno;

    std::string curTok; // Holds the current token for syntax errors
    std::string curFileName; // Holds the name of the current file being compiled
    SymbolTable symTable;
    bool compileError = false;
    ASTNode *rootNode;
}

%syntax_error
{
    error(curFileName + ", " + std::to_string(yylineno) +
            ": Syntax error near \"" + curTok + "\".");
}

%parse_accept
{
    std::cout << "\033[96mParsing done.\033[39;49m\n";
}

%parse_failure
{
    error("Parse failure.");
}

%stack_overflow
{
    error("Stack overflow.");
}

// Main parse function
%code
{
    extern int yylex();
    extern char *yytext;

    ASTNode *parse(const char *filename)
    {
        curFileName = filename;
        void *parser = ParseAlloc(malloc);
        int tokenId;

        // Uncomment for debugging
        // ParseTrace(stdout, "Parser: ");
        
        // Parse loop
        while ((tokenId = yylex()))
        {
            curTok = yytext;
            Parse(parser, tokenId, strdup(yytext));
        }

        Parse(parser, 0, NULL);
        ParseFree(parser, free);

        return rootNode;
    }
}

%token_prefix TOK_
%token_type   { const char * }

// Operator precedence
%left AND XOR OR.
%right NOT.

// Main program
program ::= enterScope compoundStmt(STMTS) exitScope. { rootNode = STMTS; }

// Compound statement
%type compoundStmt { CompoundStmtNode * }
compoundStmt(A) ::= statement(STMT).
{
    A = new CompoundStmtNode;
    A->stmts.push_back(STMT);
}
compoundStmt(A) ::= compoundStmt(STMTS) statement(NEW_STMT).
{
    STMTS->stmts.push_back(NEW_STMT);
    A = STMTS;
}

// Statement
%type statement { StmtNode * }

// Expression Statement
statement(A) ::= expr(EXPR) SEMICOLON. { A = new ExprStmtNode(EXPR); }

// Connection
statement(A) ::= ident(IDENT) CONNECTION expr(EXPR) SEMICOLON.
{
    A = new ExprStmtNode(new BinaryOpNode(Operation::Connection, IDENT, EXPR));
}

// Wire definition
statement(A) ::= WIRE ident(IDENT) SEMICOLON.
{
    A = new WireDef(IDENT, new BoolNode(false));
}
statement(A) ::= WIRE ident(IDENT) CONNECTION expr(EXPR) SEMICOLON.
{
    A = new WireDef(IDENT, EXPR);
}

// When statement
statement(A) ::= WHEN expr(CONDITION) SEMICOLON compoundStmt(STMTS) END.
{
    CompoundStmtNode *emptyStmt = new CompoundStmtNode();
    emptyStmt->stmts.push_back(new StmtNode());
    A = new WhenElseStmtNode(CONDITION, STMTS, emptyStmt);
}
statement(A) ::= WHEN expr(CONDITION) SEMICOLON compoundStmt(STMTS) ELSE
        compoundStmt(ELSE_STMTS) END.
{
    A = new WhenElseStmtNode(CONDITION, STMTS, ELSE_STMTS);
}

// Module definition
statement(A) ::= MODULE ident(IDENT) portList(PORTS) SEMICOLON
        compoundStmt(STMTS) END.
{
    A = new ModuleDef(IDENT, PORTS, STMTS);
}
%type portList { std::vector<Port> }
portList(A) ::= portDef(PORT).
{
    A = std::vector<Port>();
    A.push_back(*PORT);
}
portList(A) ::= portList(PORTS) COMMA portDef(NEW_PORT).
{
    PORTS.push_back(*NEW_PORT);
    A = PORTS;
}

%type portDef { Port * }
portDef(A) ::= INPUT ident(IDENT).
{
    if (symTable.isIdentInScope(IDENT->ident))
    {
        compileError = true;
        error(curFileName + ", " + std::to_string(yylineno) +
                ": Scope error: redefinition of identifier, \"" + IDENT->ident +
                "\".");
    }
    else
        symTable.insertSym(IDENT->ident, SymType::Input);

    A = new Port(IDENT, Type::Input);
}
portDef(A) ::= OUTPUT ident(IDENT).
{
    if (symTable.isIdentInScope(IDENT->ident))
    {
        compileError = true;
        error(curFileName + ", " + std::to_string(yylineno) +
                ": Scope error: redefinition of identifier, \"" + IDENT->ident +
                "\".");
    }
    else
        symTable.insertSym(IDENT->ident, SymType::Output);

    A = new Port(IDENT, Type::Output);
}

// Module intantiation
statement(A) ::= ident(MOD_IDENT) ident(INST_IDENT) argumentList(ARG_LIST)
        SEMICOLON.
{
    A = new ModuleInstNode(MOD_IDENT, INST_IDENT, ARG_LIST);
}

// Argument list
%type argumentList { std::vector<ExprNode *> }
argumentList(A) ::= expr(EXPR).
{
    A = std::vector<ExprNode *>();
    A.push_back(EXPR);
}
argumentList(A) ::= argumentList(ARG_LIST) COMMA expr(NEW_EXPR).
{
    ARG_LIST.push_back(NEW_EXPR);
    A = ARG_LIST;
}

// Expressions
%type expr { ExprNode * }
expr(A) ::= LBRACKET expr(EXPR) RBRACKET. { A = EXPR; }
expr(A) ::= expr(LHS) AND expr(RHS).
{
    A = new BinaryOpNode(Operation::And, LHS, RHS);
}
expr(A) ::= expr(LHS) OR expr(RHS).
{
    A = new BinaryOpNode(Operation::Or, LHS, RHS);
}
expr(A) ::= expr(LHS) XOR expr(RHS).
{
    A = new BinaryOpNode(Operation::Xor, LHS, RHS);
}
expr(A) ::= NOT expr(EXPR).
{
    A = new UnaryOpNode(Operation::Not, EXPR);
}

// Boolean values
expr(A) ::= TRUE.  { A = new BoolNode(true); }
expr(A) ::= FALSE. { A = new BoolNode(false); }

// Identifiers
expr(A) ::= ident(IDENT). { A = IDENT; }

// Identifier
%type ident { IdentNode * }
ident(A) ::= IDENT(ID). { A = new IdentNode(ID); }

// Scope
enterScope ::= . { symTable.enterScope(); }
exitScope ::= .  { symTable.exitScope();  }
